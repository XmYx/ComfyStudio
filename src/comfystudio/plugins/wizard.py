# # import copy
# # from qtpy.QtWidgets import QAction, QInputDialog, QMessageBox
# #
# # def register(app):
# #     shotWizardAction = QAction("Shot Wizard", app)
# #     file_menu = None
# #     for action in app.menuBar().actions():
# #         if action.text() == "File":
# #             file_menu = action.menu()
# #             break
# #     if file_menu:
# #         file_menu.addAction(shotWizardAction)
# #     shotWizardAction.triggered.connect(lambda: run_shot_wizard(app))
# #
# # def run_shot_wizard(app):
# #     import os, requests, json, time, copy
# #     from qtpy.QtWidgets import QMessageBox, QInputDialog
# #
# #     # Load the workflow file
# #     llm_workflow_path = os.path.join(os.path.dirname(__file__), "..", "workflows", "llm", "ollama_sky.json")
# #     try:
# #         with open(llm_workflow_path, "r") as wf:
# #             workflow_json = json.load(wf)
# #
# #             print(workflow_json)
# #
# #     except Exception as e:
# #         QMessageBox.critical(app, "Error", f"Failed to load workflow: {e}")
# #         return
# #
# #     from qtpy.QtWidgets import QInputDialog
# #     for node in workflow_json.values():
# #         if node.get('_meta', {}).get('title', '').lower() == 'input prompt':
# #             current_text = node['inputs'].get('text', '')
# #             new_prompt, ok = QInputDialog.getText(app, "Edit Input Prompt",
# #                                                   "Enter new input prompt:",
# #                                                   text=current_text)
# #             if ok and new_prompt:
# #                 node['inputs']['text'] = new_prompt
# #             break
# #
# #     comfy_ip = app.settingsManager.get("comfy_ip", "http://localhost:8188").rstrip("/")
# #     prompt_url = f"{comfy_ip}/prompt"
# #     headers = {"Content-Type": "application/json"}
# #     data = {"prompt": workflow_json}
# #
# #     # Send the workflow to ComfyUI
# #     try:
# #         resp = requests.post(prompt_url, headers=headers, json=data)
# #         resp.raise_for_status()
# #         result = resp.json()
# #
# #         print(result)
# #
# #         prompt_id = result.get("prompt_id")
# #     except Exception as e:
# #         QMessageBox.critical(app, "Error", f"Failed to send workflow: {e}")
# #         return
# #
# #     # Poll for result
# #     history_url = f"{comfy_ip}/history/{prompt_id}"
# #     result_data = None
# #     for _ in range(200):  # poll up to ~60 seconds
# #         time.sleep(2)
# #         hist_resp = requests.get(history_url)
# #         if hist_resp.status_code == 200:
# #             result_data = hist_resp.json()
# #             if result_data:
# #                 break
# #     if not result_data:
# #         QMessageBox.critical(app, "Error", "No result received for workflow.")
# #         return
# #     print(result_data)
# #     # Extract generated text lines from the result
# #     generated_strings = []
# #     outputs = result_data.get(prompt_id, {}).get("outputs", {})
# #     for node_id, output_data in outputs.items():
# #         texts = output_data.get("text", [])
# #         if texts:
# #             generated_strings.extend(texts)
# #
# #     if not generated_strings:
# #         QMessageBox.information(app, "Shot Wizard", "No text lines generated by workflow.")
# #         return
# #
# #     # Split each string on newlines and filter out empty lines
# #     lines = []
# #     for text in generated_strings:
# #         for line in text.splitlines():
# #             stripped = line.strip()
# #             if stripped:
# #                 lines.append(stripped)
# #
# #     if not lines:
# #         QMessageBox.information(app, "Shot Wizard", "No valid lines generated by workflow.")
# #         return
# #
# #     # Use the rest of the original code to select field and create shots
# #     possible_fields = []
# #     param_mapping = {}
# #     for param in app.defaultShotParams:
# #         key = f"ShotParam: {param['name']}"
# #         possible_fields.append(key)
# #         param_mapping[key] = ('shotParams', param)
# #     for param in app.defaultImageParams:
# #         key = f"ImageParam: {param['name']}"
# #         possible_fields.append(key)
# #         param_mapping[key] = ('imageParams', param)
# #     for param in app.defaultVideoParams:
# #         key = f"VideoParam: {param['name']}"
# #         possible_fields.append(key)
# #         param_mapping[key] = ('videoParams', param)
# #
# #     if not possible_fields:
# #         QMessageBox.information(app, "Info", "No parameter fields available for Shot Wizard.")
# #         return
# #
# #     field, ok = QInputDialog.getItem(app, "Select Field",
# #                                      "Select a field to import generated lines into:",
# #                                      possible_fields, 0, False)
# #     if not ok or not field:
# #         return
# #
# #     array_name, default_param = param_mapping[field]
# #     reference_shot = None
# #     if app.shots and app.currentShotIndex is not None and app.currentShotIndex >= 0:
# #         reference_shot = app.shots[app.currentShotIndex]
# #
# #     for line in lines:
# #         if reference_shot:
# #             new_shot = copy.deepcopy(reference_shot)
# #             new_shot["name"] = f"Shot {len(app.shots) + 1}"
# #             new_shot["stillPath"] = ""
# #             new_shot["videoPath"] = ""
# #             new_shot["imageVersions"] = []
# #             new_shot["videoVersions"] = []
# #             new_shot["currentImageVersion"] = -1
# #             new_shot["currentVideoVersion"] = -1
# #         else:
# #             new_shot = {
# #                 "name": f"Shot {len(app.shots) + 1}",
# #                 "shotParams": copy.deepcopy(app.defaultShotParams),
# #                 "imageParams": copy.deepcopy(app.defaultImageParams),
# #                 "videoParams": copy.deepcopy(app.defaultVideoParams),
# #                 "params": [],
# #                 "stillPath": "",
# #                 "videoPath": "",
# #                 "imageVersions": [],
# #                 "videoVersions": [],
# #                 "currentImageVersion": -1,
# #                 "currentVideoVersion": -1
# #             }
# #         params_array = new_shot[array_name]
# #         for param in params_array:
# #             if param["name"] == default_param["name"]:
# #                 param["value"] = line
# #                 break
# #         app.shots.append(new_shot)
# #
# #     app.updateList()
# #     QMessageBox.information(app, "Shot Wizard", f"Imported {len(lines)} shots from Shot Wizard.")
# import copy
# import os
# import requests
# import json
# import time
#
# from qtpy.QtWidgets import (
#     QAction,
#     QMessageBox,
#     QInputDialog,
#     QDialog,
#     QVBoxLayout,
#     QFormLayout,
#     QDialogButtonBox,
#     QPlainTextEdit,
#     QLabel
# )
#
# def register(app):
#     shotWizardAction = QAction("Shot Wizard", app)
#     file_menu = None
#     for action in app.menuBar().actions():
#         if action.text() == "File":
#             file_menu = action.menu()
#             break
#     if file_menu:
#         file_menu.addAction(shotWizardAction)
#     shotWizardAction.triggered.connect(lambda: run_shot_wizard(app))
#
# def run_shot_wizard(app):
#     """
#     1. Let user select an LLM workflow from workflows/llm.
#     2. Load the workflow JSON.
#     3. For each node that has a 'text' input, show a multiline editor with the node title.
#     4. After editing, send the workflow to ComfyUI, poll the result, split lines, create shots.
#     """
#
#     # Step 1: Choose an LLM workflow
#     llm_dir = os.path.join(os.path.dirname(__file__), "..", "workflows", "llm")
#     if not os.path.isdir(llm_dir):
#         QMessageBox.warning(app, "Error", f"No LLM workflow folder found at: {llm_dir}")
#         return
#
#     # Gather .json files from llm_dir
#     llm_workflows = [f for f in os.listdir(llm_dir) if f.lower().endswith(".json")]
#     if not llm_workflows:
#         QMessageBox.warning(app, "Error", "No LLM workflows found in 'workflows/llm'.")
#         return
#
#     # Ask user to pick a workflow
#     workflow_file, ok = QInputDialog.getItem(app, "Select LLM Workflow",
#                                              "Choose a workflow to use:",
#                                              llm_workflows, 0, False)
#     if not ok or not workflow_file:
#         return
#
#     llm_workflow_path = os.path.join(llm_dir, workflow_file)
#
#     # Step 2: Load the workflow JSON
#     try:
#         with open(llm_workflow_path, "r") as wf:
#             workflow_json = json.load(wf)
#     except Exception as e:
#         QMessageBox.critical(app, "Error", f"Failed to load workflow: {e}")
#         return
#
#     # Step 3: Let the user edit the text input of any relevant nodes
#     # We'll look for 'inputs' that have 'text' and show a multiline editor for each.
#     editable_nodes = []
#     for node_id, node_data in workflow_json.items():
#         inputs = node_data.get("inputs", {})
#         if "text" in inputs.keys():
#             # This node has a single 'text' string
#             title = node_data.get("_meta", {}).get("title", f"Node {node_id}")
#             if 'prompt' in title:
#                 editable_nodes.append((node_id, title, inputs["text"]))
#         if "seed" in inputs.keys():
#             title = node_data.get("_meta", {}).get("title", f"Node {node_id}")
#             if "generate" in title.lower():
#                 editable_nodes.append((node_id, title, inputs["seed"]))
#     # If no editable nodes found, proceed. Otherwise, show a dialog with multiline edits.
#     if editable_nodes:
#         edited_data = showNodeEditorDialog(app, editable_nodes)
#         if edited_data is None:
#             return  # user cancelled
#         # Update the workflow JSON with the edited text
#         for node_id, new_text in edited_data.items():
#             workflow_json[node_id]["inputs"]["text"] = new_text
#
#     # Step 4: Send workflow to ComfyUI and poll result
#     comfy_ip = app.settingsManager.get("comfy_ip", "http://localhost:8188").rstrip("/")
#     prompt_url = f"{comfy_ip}/prompt"
#     headers = {"Content-Type": "application/json"}
#     data = {"prompt": workflow_json}
#
#     try:
#         resp = requests.post(prompt_url, headers=headers, json=data)
#         resp.raise_for_status()
#         result = resp.json()
#         prompt_id = result.get("prompt_id")
#     except Exception as e:
#         QMessageBox.critical(app, "Error", f"Failed to send workflow: {e}")
#         return
#
#     if not prompt_id:
#         QMessageBox.critical(app, "Error", "No prompt_id returned from ComfyUI.")
#         return
#
#     history_url = f"{comfy_ip}/history/{prompt_id}"
#     result_data = None
#     # Increase poll time if needed. Here ~ 400 seconds (200 * 2s).
#     for _ in range(200):
#         time.sleep(2)
#         hist_resp = requests.get(history_url)
#         if hist_resp.status_code == 200:
#             result_data = hist_resp.json()
#             if result_data:
#                 break
#
#     if not result_data:
#         QMessageBox.critical(app, "Error", "No result received for workflow.")
#         return
#
#     # Step 5: Extract text lines
#     generated_strings = []
#     outputs = result_data.get(prompt_id, {}).get("outputs", {})
#     for node_id, output_data in outputs.items():
#         texts = output_data.get("text", [])
#         if texts:
#             generated_strings.extend(texts)
#
#     if not generated_strings:
#         QMessageBox.information(app, "Shot Wizard", "No text lines generated by workflow.")
#         return
#
#     lines = []
#     for text in generated_strings:
#         for line in text.splitlines():
#             stripped = line.strip()
#             if stripped:
#                 lines.append(stripped)
#
#     if not lines:
#         QMessageBox.information(app, "Shot Wizard", "No valid lines generated by workflow.")
#         return
#
#     # Step 6: Let user pick the target field, create shots from lines
#     possible_fields = []
#     param_mapping = {}
#     for param in app.defaultShotParams:
#         key = f"ShotParam: {param['name']}"
#         possible_fields.append(key)
#         param_mapping[key] = ('shotParams', param)
#     for param in app.defaultImageParams:
#         key = f"ImageParam: {param['name']}"
#         possible_fields.append(key)
#         param_mapping[key] = ('imageParams', param)
#     for param in app.defaultVideoParams:
#         key = f"VideoParam: {param['name']}"
#         possible_fields.append(key)
#         param_mapping[key] = ('videoParams', param)
#
#     if not possible_fields:
#         QMessageBox.information(app, "Info", "No parameter fields available for Shot Wizard.")
#         return
#
#     field, ok = QInputDialog.getItem(app, "Select Field",
#                                      "Select a field to import generated lines into:",
#                                      possible_fields, 0, False)
#     if not ok or not field:
#         return
#
#     array_name, default_param = param_mapping[field]
#     reference_shot = None
#     if app.shots and app.currentShotIndex is not None and app.currentShotIndex >= 0:
#         reference_shot = app.shots[app.currentShotIndex]
#
#     # Create one shot per line
#     for line in lines:
#         if reference_shot:
#             new_shot = copy.deepcopy(reference_shot)
#             new_shot["name"] = f"Shot {len(app.shots) + 1}"
#             new_shot["stillPath"] = ""
#             new_shot["videoPath"] = ""
#             new_shot["imageVersions"] = []
#             new_shot["videoVersions"] = []
#             new_shot["currentImageVersion"] = -1
#             new_shot["currentVideoVersion"] = -1
#         else:
#             new_shot = {
#                 "name": f"Shot {len(app.shots) + 1}",
#                 "shotParams": copy.deepcopy(app.defaultShotParams),
#                 "imageParams": copy.deepcopy(app.defaultImageParams),
#                 "videoParams": copy.deepcopy(app.defaultVideoParams),
#                 "params": [],
#                 "stillPath": "",
#                 "videoPath": "",
#                 "imageVersions": [],
#                 "videoVersions": [],
#                 "currentImageVersion": -1,
#                 "currentVideoVersion": -1
#             }
#         params_array = new_shot[array_name]
#         for param in params_array:
#             if param["name"] == default_param["name"]:
#                 param["value"] = line
#                 break
#         app.shots.append(new_shot)
#
#     app.updateList()
#     QMessageBox.information(app, "Shot Wizard",
#                             f"Imported {len(lines)} shots from '{workflow_file}' workflow.")
#
# def showNodeEditorDialog(parent, node_list):
#     """
#     Show a dialog that lists each node's title and a multiline editor for the 'text' field.
#     node_list is a list of tuples: (node_id, title, text_value).
#     Returns a dict {node_id: edited_text} or None if user cancels.
#     """
#     dialog = QDialog(parent)
#     dialog.setWindowTitle("Edit Node Text Inputs")
#     layout = QVBoxLayout(dialog)
#
#     form = QFormLayout()
#     edit_fields = {}
#
#     for node_id, node_title, text_value in node_list:
#         label = QLabel(node_title)
#         editor = QPlainTextEdit()
#         editor.setPlainText(str(text_value))
#         form.addRow(label, editor)
#         edit_fields[node_id] = editor
#
#     layout.addLayout(form)
#
#     btns = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
#     layout.addWidget(btns)
#
#     def onAccept():
#         dialog.accept()
#
#     def onReject():
#         dialog.reject()
#
#     btns.accepted.connect(onAccept)
#     btns.rejected.connect(onReject)
#
#     if dialog.exec() == QDialog.Accepted:
#         results = {}
#         for node_id, editor in edit_fields.items():
#             results[node_id] = editor.toPlainText()
#         return results
#     else:
#         return None
import copy
import os
import random

import requests
import json
import time

from qtpy.QtWidgets import (
    QAction,
    QMessageBox,
    QInputDialog,
    QDialog,
    QVBoxLayout,
    QFormLayout,
    QDialogButtonBox,
    QPlainTextEdit,
    QLabel,
    QListWidget
)

# Custom QListWidget subclass that overrides dropEvent
class ReorderableListWidget(QListWidget):
    def dropEvent(self, event):
        super().dropEvent(event)  # Perform the default drop behavior
        # After drop completes, update the parent's shots order
        if hasattr(self.parent(), 'syncShotsFromList'):
            self.parent().syncShotsFromList()

def register(app):
    shotWizardAction = QAction("Shot Wizard", app)
    file_menu = None
    for action in app.menuBar().actions():
        if action.text() == "File":
            file_menu = action.menu()
            break
    if file_menu:
        file_menu.addAction(shotWizardAction)
    shotWizardAction.triggered.connect(lambda: run_shot_wizard(app))

def run_shot_wizard(app):
    # Step 1: Choose an LLM workflow
    llm_dir = os.path.join(os.path.dirname(__file__), "..", "workflows", "llm")
    if not os.path.isdir(llm_dir):
        QMessageBox.warning(app, "Error", f"No LLM workflow folder found at: {llm_dir}")
        return

    llm_workflows = [f for f in os.listdir(llm_dir) if f.lower().endswith(".json")]
    if not llm_workflows:
        QMessageBox.warning(app, "Error", "No LLM workflows found in 'workflows/llm'.")
        return

    workflow_file, ok = QInputDialog.getItem(app, "Select LLM Workflow",
                                             "Choose a workflow to use:",
                                             llm_workflows, 0, False)
    if not ok or not workflow_file:
        return

    llm_workflow_path = os.path.join(llm_dir, workflow_file)

    # Step 2: Load the workflow JSON
    try:
        with open(llm_workflow_path, "r") as wf:
            workflow_json = json.load(wf)
    except Exception as e:
        QMessageBox.critical(app, "Error", f"Failed to load workflow: {e}")
        return

    # Step 3: Let user edit 'text' inputs of relevant nodes
    editable_nodes = []
    for node_id, node_data in workflow_json.items():
        inputs = node_data.get("inputs", {})
        if "text" in inputs:
            title = node_data.get("_meta", {}).get("title", f"Node {node_id}")
            if 'prompt' in title.lower():
                editable_nodes.append((node_id, title, inputs["text"]))
    if editable_nodes:
        edited_data = showNodeEditorDialog(app, editable_nodes)
        if edited_data is None:
            return
        for node_id, new_text in edited_data.items():
            workflow_json[node_id]["inputs"]["text"] = new_text
            if workflow_json[node_id]["_meta"]["title"] == "input prompt":
                input_prompt = new_text

    # Step 4: Send workflow to ComfyUI and poll result
    comfy_ip = app.settingsManager.get("comfy_ip", "http://localhost:8188").rstrip("/")
    prompt_url = f"{comfy_ip}/prompt"
    headers = {"Content-Type": "application/json"}
    data = {"prompt": workflow_json}

    try:
        resp = requests.post(prompt_url, headers=headers, json=data)
        resp.raise_for_status()
        result = resp.json()
        prompt_id = result.get("prompt_id")
    except Exception as e:
        QMessageBox.critical(app, "Error", f"Failed to send workflow: {e}")
        return

    if not prompt_id:
        QMessageBox.critical(app, "Error", "No prompt_id returned from ComfyUI.")
        return

    history_url = f"{comfy_ip}/history/{prompt_id}"
    result_data = None
    for _ in range(200):
        time.sleep(2)
        hist_resp = requests.get(history_url)
        if hist_resp.status_code == 200:
            result_data = hist_resp.json()
            if result_data:
                break

    if not result_data:
        QMessageBox.critical(app, "Error", "No result received for workflow.")
        return

    # Step 5: Extract text lines from the result
    generated_strings = []
    outputs = result_data.get(prompt_id, {}).get("outputs", {})
    for node_id, output_data in outputs.items():
        texts = output_data.get("text", [])
        if texts:
            generated_strings.extend(texts)

    if not generated_strings:
        QMessageBox.information(app, "Shot Wizard", "No text lines generated by workflow.")
        return

    lines = []
    for text in generated_strings:
        for line in text.splitlines():
            stripped = line.strip()
            if stripped:
                lines.append(stripped)

    # Step 6: Ask for iteration count
    iter_count, ok = QInputDialog.getInt(app, "Iterations", "Number of iterations:", 1, 1)
    if not ok:
        iter_count = 1

    all_lines = lines.copy()
    previous_result_text = "\n".join(lines)

    # Additional iterations using ollama_iter.json if needed
    for iteration in range(2, iter_count + 1):
        iter_workflow_path = os.path.join(os.path.dirname(__file__), "..", "workflows", "llm", "ollama_iter.json")
        try:
            with open(iter_workflow_path, "r") as wf:
                iter_workflow = json.load(wf)
        except Exception as e:
            QMessageBox.critical(app, "Error", f"Failed to load iteration workflow: {e}")
            break

        # Update seed and prompt_history in iteration workflow
        for node in iter_workflow.values():
            inputs = node.get("inputs", {})

            if node.get("_meta", {}).get("title", "") == "prompt history":
                inputs["text"] = previous_result_text
            if node.get("_meta", {}).get("title", "") == "input prompt":
                inputs["text"] = input_prompt
            if "seed" in inputs:
                inputs["seed"] = random.randint(0, 2**31-1)
            # if "prompt_history" in inputs:
            #     inputs["prompt_history"] = previous_result_text


        data = {"prompt": iter_workflow}
        try:
            resp = requests.post(prompt_url, headers=headers, json=data)
            resp.raise_for_status()
            iter_result = resp.json()
            iter_prompt_id = iter_result.get("prompt_id")
        except Exception as e:
            QMessageBox.critical(app, "Error", f"Iteration {iteration} failed to send: {e}")
            break

        if not iter_prompt_id:
            QMessageBox.critical(app, "Error", f"Iteration {iteration}: No prompt_id returned.")
            break

        hist_url = f"{comfy_ip}/history/{iter_prompt_id}"
        iter_result_data = None
        for _ in range(200):
            time.sleep(2)
            hist_resp = requests.get(hist_url)
            if hist_resp.status_code == 200:
                iter_result_data = hist_resp.json()
                if iter_result_data:
                    break

        if not iter_result_data:
            QMessageBox.critical(app, "Error", f"Iteration {iteration}: No result received.")
            break

        iter_generated = []
        outputs = iter_result_data.get(iter_prompt_id, {}).get("outputs", {})
        for node_id, output_data in outputs.items():
            texts = output_data.get("text", [])
            if texts:
                iter_generated.extend(texts)

        iter_lines = []
        for text in iter_generated:
            for line in text.splitlines():
                stripped = line.strip()
                if stripped:
                    iter_lines.append(stripped)

        all_lines.extend(iter_lines)
        if iter_lines:
            previous_result_text = "\n".join(iter_lines)

    # Step 7: Select target field and create shots from accumulated lines
    possible_fields = []
    param_mapping = {}
    for param in app.defaultShotParams:
        key = f"ShotParam: {param['name']}"
        possible_fields.append(key)
        param_mapping[key] = ('shotParams', param)
    for param in app.defaultImageParams:
        key = f"ImageParam: {param['name']}"
        possible_fields.append(key)
        param_mapping[key] = ('imageParams', param)
    for param in app.defaultVideoParams:
        key = f"VideoParam: {param['name']}"
        possible_fields.append(key)
        param_mapping[key] = ('videoParams', param)

    if not possible_fields:
        QMessageBox.information(app, "Info", "No parameter fields available for Shot Wizard.")
        return

    field, ok = QInputDialog.getItem(app, "Select Field",
                                     "Select a field to import generated lines into:",
                                     possible_fields, 0, False)
    if not ok or not field:
        return

    array_name, default_param = param_mapping[field]
    reference_shot = None
    if app.shots and app.currentShotIndex is not None and app.currentShotIndex >= 0:
        reference_shot = app.shots[app.currentShotIndex]

    for line in all_lines:
        if reference_shot:
            new_shot = copy.deepcopy(reference_shot)
            new_shot["name"] = f"Shot {len(app.shots) + 1}"
            new_shot["stillPath"] = ""
            new_shot["videoPath"] = ""
            new_shot["imageVersions"] = []
            new_shot["videoVersions"] = []
            new_shot["currentImageVersion"] = -1
            new_shot["currentVideoVersion"] = -1
        else:
            new_shot = {
                "name": f"Shot {len(app.shots) + 1}",
                "shotParams": copy.deepcopy(app.defaultShotParams),
                "imageParams": copy.deepcopy(app.defaultImageParams),
                "videoParams": copy.deepcopy(app.defaultVideoParams),
                "params": [],
                "stillPath": "",
                "videoPath": "",
                "imageVersions": [],
                "videoVersions": [],
                "currentImageVersion": -1,
                "currentVideoVersion": -1
            }
        params_array = new_shot[array_name]
        for param in params_array:
            if param["name"] == default_param["name"]:
                param["value"] = line
                break
        app.shots.append(new_shot)

    app.updateList()
    QMessageBox.information(app, "Shot Wizard",
                            f"Imported {len(all_lines)} shots from '{workflow_file}' workflow.")

def showNodeEditorDialog(parent, node_list):
    dialog = QDialog(parent)
    dialog.setWindowTitle("Edit Node Text Inputs")
    layout = QVBoxLayout(dialog)

    form = QFormLayout()
    edit_fields = {}

    for node_id, node_title, text_value in node_list:
        label = QLabel(node_title)
        editor = QPlainTextEdit()
        editor.setPlainText(str(text_value))
        form.addRow(label, editor)
        edit_fields[node_id] = editor

    layout.addLayout(form)

    btns = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
    layout.addWidget(btns)

    btns.accepted.connect(dialog.accept)
    btns.rejected.connect(dialog.reject)

    if dialog.exec() == QDialog.Accepted:
        results = {}
        for node_id, editor in edit_fields.items():
            results[node_id] = editor.toPlainText()
        return results
    else:
        return None
